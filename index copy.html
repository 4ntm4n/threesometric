<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Threesometric – Glasskiva + CameraControls</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; overflow: hidden; background-color: #0f3a2d; cursor: crosshair; }
    canvas { display: block; position: absolute; top: 0; left: 0; }
    #virtual-cursor {
      position: fixed;
      width: 12px;
      height: 12px;
      border: 2px solid white;
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 9999;
      box-sizing: border-box;
    }
    #hud {
      position: fixed; left: 8px; bottom: 8px; z-index: 10000;
      font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:#ddd; opacity:.85; background: rgba(0,0,0,.25); padding:8px 10px; border-radius:8px;
      backdrop-filter: blur(6px);
    }
    #hud kbd { background:#111; padding:1px 4px; border-radius:4px; border:1px solid #333; }
  </style>
</head>
<body>
  <div id="virtual-cursor"></div>
  <div id="hud">
    <div><strong>Inspektion:</strong> rotera/pan/zoom • <strong>Klick:</strong> välj startpunkt → Ritläge</div>
    <div><strong>Ritläge:</strong> pan/zoom tillåtet (rotation av). Vänsterklick = commit, <kbd>Esc</kbd> = avbryt → Inspektion</div>
    <div>Vinkel snäpps vid commit (30°, 90°, 150°, 210°, 270°, 330°)</div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/controls/CameraControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/CameraControls.js"
    }
  }
  </script>

  <script type="module">
  import * as THREE from 'three';
  import CameraControls from 'camera-controls';
  CameraControls.install({ THREE });

  // --- Scen, kamera, renderer ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f3a2d);

  const frustumSize = 20;
  const aspect = window.innerWidth / window.innerHeight;
  const camera = new THREE.OrthographicCamera(
    -frustumSize * aspect / 2,
     frustumSize * aspect / 2,
     frustumSize / 2,
    -frustumSize / 2,
    1e-4,             // Fasta, stora clipping-plan
    1e9
  );
  camera.position.set(50, 50, 50);
  camera.lookAt(0,0,0);

  const renderer3D = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
  renderer3D.setSize(window.innerWidth, window.innerHeight);
  renderer3D.sortObjects = true;
  document.body.appendChild(renderer3D.domElement);

  const clock = new THREE.Clock();
  const controls = new CameraControls(camera, renderer3D.domElement);
  controls.enabled = true;
  controls.mouseButtons.left   = CameraControls.ACTION.NONE;   // vi hanterar vänsterklick själva
  controls.mouseButtons.middle = CameraControls.ACTION.TRUCK;  // pan
  controls.mouseButtons.right  = CameraControls.ACTION.ROTATE; // rotation (stängs av i ritläge)
  controls.minZoom = 0.1;
  controls.maxZoom = 10;
  controls.smoothTime = 0.05;
  controls.draggingSmoothTime = 0.01;
  controls.truckSpeed = 4.0;
  controls.dollyToCursor = true; // på i inspektion, av i ritläge

  // ---- SCENE CONTENT ----
  const gridHelper = new THREE.GridHelper(100, 100, 0x3a6f62, 0x64b2a3);
  gridHelper.renderOrder = 0; // bakom linjerna
  scene.add(gridHelper);

  const idleMarker = new THREE.Mesh(
    new THREE.SphereGeometry(0.2, 16, 8),
    new THREE.MeshBasicMaterial({ color: 0xffffff })
  );
  idleMarker.renderOrder = 2;
  scene.add(idleMarker);

  const pickPlaneMesh = new THREE.Mesh(
    new THREE.PlaneGeometry(100, 100),
    new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide })
  );
  pickPlaneMesh.rotation.x = -Math.PI / 2;
  scene.add(pickPlaneMesh);

  const raycaster = new THREE.Raycaster();

  const overlay = document.createElement('canvas');
  overlay.width = window.innerWidth;
  overlay.height = window.innerHeight;
  overlay.style.pointerEvents = 'none';
  document.body.appendChild(overlay);
  const ctx = overlay.getContext('2d');

  const virtualCursorEl = document.getElementById('virtual-cursor');
  let virtualCursorPix = { x: 0, y: 0 };
  let start2D = { x: 0, y: 0 };
  let lineStartPoint = new THREE.Vector3();

  const modelGroup = new THREE.Group();
  scene.add(modelGroup);

  const permanentLines = [];
  const permanentVertices = new THREE.Group();
  modelGroup.add(permanentVertices);

  // NEW: grupp för pickables (osynliga mesh runt linjer)
  const pickables = new THREE.Group();
  scene.add(pickables);

  // --- helper: skapa osynlig cylinder runt linje ---
  function makePickCylinder(start, end, radius = 0.2) {
    const dir = new THREE.Vector3().subVectors(end, start);
    const len = dir.length();
    const geom = new THREE.CylinderGeometry(radius, radius, len, 6, 1, true);
    const mat = new THREE.MeshBasicMaterial({ visible: false });
    const mesh = new THREE.Mesh(geom, mat);

    // orientera cylindern längs linjen
    mesh.position.copy(start).add(end).multiplyScalar(0.5);
    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());
    mesh.userData = { start: start.clone(), end: end.clone() }; // spara segmentet
    return mesh;
  }

  // --- helper: närmaste punkt på linjesegment ---
  function closestPointOnSegment(p, a, b) {
    const ab = new THREE.Vector3().subVectors(b, a);
    const t = Math.max(0, Math.min(1, new THREE.Vector3().subVectors(p, a).dot(ab) / ab.lengthSq()));
    return a.clone().add(ab.multiplyScalar(t));
  }

  // --- BASELINE för fit ---
  const BASELINE_BOUNDS = new THREE.Box3(
    new THREE.Vector3(-60,-5,-60),
    new THREE.Vector3( 60, 5, 60)
  );

  // --- ISO referens ---
  const ISO_TARGET0 = new THREE.Vector3(0,0,0);
  const ISO_OFFSET  = camera.position.clone().sub(ISO_TARGET0);
  const sph = new THREE.Spherical().setFromVector3(ISO_OFFSET.clone());
  const ISO_THETA = sph.theta, ISO_PHI = sph.phi;

  // --- lägen ---
  let isDrawing = false;
  let hasStart = false;
  let isInteracting = false; // TRUE mellan controlstart/controlend
  let pendingDraw = false;   // vänta tills pointer lock innan gummisnodden startar

  // --- NODE-SNAP ---
  const SNAP_RADIUS_PX = 12; // justera vid behov; kan göras inställningsbar

  function projectTo2D(v3) {
    const v = v3.clone().project(camera);
    return { x: (v.x + 1) * 0.5 * overlay.width, y: (-v.y + 1) * 0.5 * overlay.height };
  }

  function findNearestNode2D(screenX, screenY) {
    // projectTo2D ger coords i window-pixlar; jämför mot event.clientX/Y
    let nearest = null;
    let bestDist = SNAP_RADIUS_PX;
    permanentVertices.children.forEach(node => {
      const pix = projectTo2D(node.position);
      const dx = pix.x - screenX;
      const dy = pix.y - screenY;
      const d = Math.hypot(dx, dy);
      if (d < bestDist) { bestDist = d; nearest = node; }
    });
    return nearest ? nearest.position.clone() : null;
  }

  function setIdleMarkerColor(hex) {
    idleMarker.material.color.setHex(hex);
  }

  // --- utilities ---
  function addVertexSphere(pos, color=0xffdede) {
    const s = new THREE.Mesh(
      new THREE.SphereGeometry(0.1, 16, 8),
      new THREE.MeshBasicMaterial({ color, depthTest:false, depthWrite:false })
    );
    s.renderOrder = 1;
    s.position.copy(pos);
    permanentVertices.add(s);
  }

  function makeLineMaterial() {
    return new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: false,
      depthTest: false,   // linjerna klipps inte av z-buffer
      depthWrite: false
    });
  }

  function getNDCFromEvent(e) {
    const rect = renderer3D.domElement.getBoundingClientRect();
    const x = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
    const y = -( (e.clientY - rect.top) / rect.height ) * 2 + 1;
    return new THREE.Vector2(x, y);
  }

  // --- dela kalibreringen ---
  function recomputeStart2D() {
    start2D = projectTo2D(lineStartPoint); // uppdatera endast projektionen
  }
  function setVirtualCursorTo2D(pix) {
    virtualCursorPix.x = pix.x; virtualCursorPix.y = pix.y;
    const clampedX = Math.max(-9999, Math.min(window.innerWidth + 9999, pix.x));
    const clampedY = Math.max(-9999, Math.min(window.innerHeight + 9999, pix.y));
    virtualCursorEl.style.left = clampedX + 'px'; virtualCursorEl.style.top = clampedY + 'px';
  }
  function recenterCursorToStart() {
    recomputeStart2D();
    setVirtualCursorTo2D({ x: start2D.x, y: start2D.y }); // flytta pekaren
  }

  function pixelsPerWorldUnit(dir3D, origin3D) {
    const step = 1;
    const p0 = projectTo2D(origin3D);
    const p1 = projectTo2D(origin3D.clone().add(dir3D.clone().normalize().multiplyScalar(step)));
    const dx = p1.x - p0.x, dy = p1.y - p0.y;
    const d = Math.hypot(dx, dy);
    return d < 1e-6 ? 1e-6 : d;
  }

  const ISO_ANGLES = [30, 90, 150, 210, 270, 330];
  function angleToIsoDir3D(angleDeg) {
    const dirs = {
      330: new THREE.Vector3( 1,  0,  0),
       30: new THREE.Vector3( 0,  0, -1),
       90: new THREE.Vector3( 0,  1,  0),
      150: new THREE.Vector3(-1,  0,  0),
      210: new THREE.Vector3( 0,  0,  1),
      270: new THREE.Vector3( 0, -1,  0),
    };
    return dirs[angleDeg].clone();
  }

  function snapAngleDeg(rawAngle) {
    const norm = ((rawAngle % 360) + 360) % 360;
    let best = ISO_ANGLES[0], bestDiff = 1e9;
    for (const a of ISO_ANGLES) {
      const d = Math.min(Math.abs(norm - a), 360 - Math.abs(norm - a));
      if (d < bestDiff) { bestDiff = d; best = a; }
    }
    return best;
  }

  function drawOverlay() {
    ctx.clearRect(0,0,overlay.width, overlay.height);
    if (hasStart) {
      ctx.fillStyle = 'rgba(255,200,200,.9)';
      ctx.beginPath(); ctx.arc(start2D.x, start2D.y, 3, 0, Math.PI*2); ctx.fill();
    }
    if (hasStart && isDrawing) {
      ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(start2D.x, start2D.y); ctx.lineTo(virtualCursorPix.x, virtualCursorPix.y); ctx.stroke();
    }
  }

  // Kamerahelpers (frustum-mesh kan kommenteras på/av)
  function buildOrUpdateFrustumBox() {}

  // Kamera/utils
  function lookIsoAt(target, smooth=false) {
    const pos = target.clone().add(ISO_OFFSET);
    return controls.setLookAt(pos.x, pos.y, pos.z, target.x, target.y, target.z, smooth);
  }

  // ISO-fit: beräkna bara zoom/pan – INTE near/far
  async function fitBoxOrthoIso(box, paddingRatio = 0.08, smooth = true) {
    const prev = {
      minPolar: controls.minPolarAngle, maxPolar: controls.maxPolarAngle,
      minAzim: controls.minAzimuthAngle, maxAzim: controls.maxAzimuthAngle,
      rightMouse: controls.mouseButtons.right,
      dollyToCursor: controls.dollyToCursor,
    };
    controls.minPolarAngle = controls.maxPolarAngle = ISO_PHI;
    controls.minAzimuthAngle = controls.maxAzimuthAngle = ISO_THETA;
    controls.mouseButtons.right = CameraControls.ACTION.NONE;
    controls.dollyToCursor = true;

    const target = box.getCenter(new THREE.Vector3());
    await lookIsoAt(target, smooth);

    // Extenter i kamerarummet:
    camera.updateMatrixWorld(true);
    const view = camera.matrixWorldInverse;
    const corners = [
      new THREE.Vector3(box.min.x, box.min.y, box.min.z),
      new THREE.Vector3(box.min.x, box.min.y, box.max.z),
      new THREE.Vector3(box.min.x, box.max.y, box.min.z),
      new THREE.Vector3(box.min.x, box.max.y, box.max.z),
      new THREE.Vector3(box.max.x, box.min.y, box.min.z),
      new THREE.Vector3(box.max.x, box.min.y, box.max.z),
      new THREE.Vector3(box.max.x, box.max.y, box.min.z),
      new THREE.Vector3(box.max.x, box.max.y, box.max.z),
    ];
    let minX=+Infinity, maxX=-Infinity, minY=+Infinity, maxY=-Infinity;
    for (const w of corners) {
      const v = w.clone().applyMatrix4(view);
      minX = Math.min(minX, v.x);  maxX = Math.max(maxX, v.x);
      minY = Math.min(minY, v.y);  maxY = Math.max(maxY, v.y);
    }
    const widthWorld  = maxX - minX;
    const heightWorld = maxY - minY;

    const baseWidth  = (camera.right - camera.left);
    const baseHeight = (camera.top - camera.bottom);
    const padFactor = 1 + paddingRatio * 2;

    const needZoomX = widthWorld  > 0 ? (baseWidth  / (widthWorld  * padFactor)) : controls.maxZoom;
    const needZoomY = heightWorld > 0 ? (baseHeight / (heightWorld * padFactor)) : controls.maxZoom;

    let targetZoom = Math.min(needZoomX, needZoomY);
    targetZoom = Math.min(Math.max(targetZoom, controls.minZoom), controls.maxZoom);
    await controls.zoomTo(targetZoom, smooth);

    // Återställ kontroller
    controls.minPolarAngle   = prev.minPolar;
    controls.maxPolarAngle   = prev.maxPolar;
    controls.minAzimuthAngle = prev.minAzim;
    controls.maxAzimuthAngle = prev.maxAzim;
    controls.mouseButtons.right = prev.rightMouse;
    controls.dollyToCursor = prev.dollyToCursor;
  }

  // --- Läge: Rit ---
  function enterDrawMode(startPoint) {
    // Aktivera inte ritningen ännu → vänta tills pointer lock är klart
    pendingDraw = true;
    hasStart = true;

    // Lås ISO + stäng av rotation; dollyToCursor AV i ritläge
    controls.minPolarAngle   = ISO_PHI;
    controls.maxPolarAngle   = ISO_PHI;
    controls.minAzimuthAngle = ISO_THETA;
    controls.maxAzimuthAngle = ISO_THETA;
    controls.mouseButtons.right = CameraControls.ACTION.NONE;
    controls.dollyToCursor = false;
    controls.enabled = true;

    // Flytta kameran till ISO mot startpunkten och begär pointer lock
    return lookIsoAt(startPoint, true).then(() => {
      renderer3D.domElement.requestPointerLock();
    });
  }

  // --- Läge: Inspektion ---
  function enterInspectModeUnlocked() {
    controls.minPolarAngle   = 0.01;
    controls.maxPolarAngle   = Math.PI - 0.01;
    controls.minAzimuthAngle = -Infinity;
    controls.maxAzimuthAngle = Infinity;
    controls.mouseButtons.right = CameraControls.ACTION.ROTATE;
    controls.dollyToCursor = true;
    controls.enabled = true;
    virtualCursorEl.style.display = 'none';
    if (document.pointerLockElement) document.exitPointerLock();
  }

  async function resetIsoAndFitAll() {
    const modelBox = new THREE.Box3().setFromObject(modelGroup);
    const fitBox = modelBox.isEmpty() ? BASELINE_BOUNDS.clone() : modelBox.union(BASELINE_BOUNDS.clone());
    await fitBoxOrthoIso(fitBox, 0.08, true);
    enterInspectModeUnlocked(); // rotation på efteråt
  }

  function enterInspectMode(runIsoFit=false) {
    if (!runIsoFit) {
      enterInspectModeUnlocked();
      return Promise.resolve();
    }
    return resetIsoAndFitAll();
  }

  // ---- INIT ----
  (async function init() {
    await enterInspectMode(true); // ISO-fit; near/far är fasta & stora → ingen clipping
  })();

  // --- Input ---
  function onMouseMove(e) {
    if (document.pointerLockElement) {
      if (isDrawing && hasStart) {
        setVirtualCursorTo2D({ x: virtualCursorPix.x + e.movementX, y: virtualCursorPix.y + e.movementY });
      }
    } else {
      // INSPEKTION: prio = Nod-snap → Linje → Plan
      const nodeSnapPos = findNearestNode2D(e.clientX, e.clientY);
      if (nodeSnapPos) {
        idleMarker.position.copy(nodeSnapPos);
        setIdleMarkerColor(0x80ff80);
        return;
      } else {
        setIdleMarkerColor(0xffffff);
      }

      const ndc = getNDCFromEvent(e);
      raycaster.setFromCamera(ndc, camera);

      // Linje (pickables)
      const hits = raycaster.intersectObjects(pickables.children, false);
      if (hits.length > 0) {
        const hit = hits[0];
        const seg = hit.object.userData;
        const nearest = closestPointOnSegment(hit.point, seg.start, seg.end);
        idleMarker.position.copy(nearest);
        return;
      }

      // Plan
      const hit = raycaster.intersectObject(pickPlaneMesh);
      if (hit.length) idleMarker.position.copy(hit[0].point);
    }
  }

  function isPointInFrustum(point3D) {
    const v = point3D.clone().project(camera);
    return v.x >= -1 && v.x <= 1 && v.y >= -1 && v.y <= 1 && v.z >= -1 && v.z <= 1;
  }

  function onPointerDown(e) {
    if (e.button === 0) {
      if (!document.pointerLockElement) {
        // INSPEKTION: klick = välj startpunkt (nod → linje → plan)
        const nodeSnapPos = findNearestNode2D(e.clientX, e.clientY);
        if (nodeSnapPos) {
          lineStartPoint.copy(nodeSnapPos);
          addVertexSphere(lineStartPoint, 0xffdede);
          enterDrawMode(lineStartPoint);
          return;
        }

        const ndc = getNDCFromEvent(e);
        raycaster.setFromCamera(ndc, camera);

        // Linje-träff
        const hits = raycaster.intersectObjects(pickables.children, false);
        if (hits.length > 0) {
          const hit = hits[0];
          const seg = hit.object.userData;
          const nearest = closestPointOnSegment(hit.point, seg.start, seg.end);
          lineStartPoint.copy(nearest);
          addVertexSphere(lineStartPoint, 0xffdede);
          enterDrawMode(lineStartPoint);
          return;
        }

        // Fallback: markplanet
        const hit = raycaster.intersectObject(pickPlaneMesh);
        if (hit.length) {
          lineStartPoint.copy(hit[0].point);
          addVertexSphere(lineStartPoint, 0xffdede);
          enterDrawMode(lineStartPoint);
        }

      } else {
        // RITLÄGE: commit
        if (isDrawing && hasStart && !isInteracting) {
          const dx = virtualCursorPix.x - start2D.x;
          const dy = start2D.y - virtualCursorPix.y;
          const rawAngle = Math.atan2(dy, dx) * 180 / Math.PI;
          const snapped = snapAngleDeg(rawAngle);
          const dir3D = angleToIsoDir3D(snapped);
          const ppu = pixelsPerWorldUnit(dir3D, lineStartPoint);
          const pixelsLen = Math.hypot(dx, dy);
          const worldLen = pixelsLen / ppu;
          if (worldLen > 1e-6) {
            const end3D = lineStartPoint.clone().add(dir3D.multiplyScalar(worldLen));
            const geom = new THREE.BufferGeometry().setFromPoints([lineStartPoint, end3D]);
            const line = new THREE.Line(geom, makeLineMaterial());
            line.renderOrder = 1;
            modelGroup.add(line);
            permanentLines.push(line);
            addVertexSphere(end3D, 0xffdede);

            // Skapa pick-cylinder för raycast
            const pickCyl = makePickCylinder(lineStartPoint, end3D);
            pickables.add(pickCyl);

            lineStartPoint.copy(end3D);

            const maybePan = (!isPointInFrustum(end3D))
              ? lookIsoAt(end3D, true).then(() => { if (isDrawing) recenterCursorToStart(); })
              : Promise.resolve();

            maybePan.then(() => { recenterCursorToStart(); });
          }
        }
      }
    }
  }

  function onKeyUp(e) {
    if (e.code === 'Escape') {
      isDrawing = false; hasStart = false; pendingDraw = false;
      virtualCursorEl.style.display = 'none';
      if (document.pointerLockElement) document.exitPointerLock();
      enterInspectMode(true); // ISO-fit (egen)
    }
  }

  function onPointerLockChange() {
    if (!document.pointerLockElement) {
      virtualCursorEl.style.display = 'none';
    } else {
      if (hasStart) {
        virtualCursorEl.style.display = 'block';
        recenterCursorToStart(); // pekaren hoppar till start först NU
        if (pendingDraw) { isDrawing = true; pendingDraw = false; }
      }
    }
  }

  function onResize() {
    const aspect = window.innerWidth / window.innerHeight;
    camera.left   = -frustumSize * aspect / 2;
    camera.right  =  frustumSize * aspect / 2;
    camera.top    =  frustumSize / 2;
    camera.bottom = -frustumSize / 2;
    camera.updateProjectionMatrix();
    renderer3D.setSize(window.innerWidth, window.innerHeight);
    overlay.width  = window.innerWidth;
    overlay.height = window.innerHeight;
    if (isDrawing && hasStart) recomputeStart2D();
  }

  // Synka gummisnodden under CameraControls-interaktioner
  controls.addEventListener('controlstart', () => { 
    isInteracting = true;  
    if (isDrawing && hasStart) recomputeStart2D();
  });
  controls.addEventListener('control',      () => { 
    if (isDrawing && hasStart) recomputeStart2D();
  });
  controls.addEventListener('controlend',   () => { 
    isInteracting = false; 
    if (isDrawing && hasStart) recomputeStart2D();
  });

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    controls.update(delta);

    // Under ritläge: håll start2D i synk varje frame
    if (isDrawing && hasStart) recomputeStart2D();

    buildOrUpdateFrustumBox();
    renderer3D.render(scene, camera);
    drawOverlay();
  }

  renderer3D.domElement.addEventListener('mousemove', onMouseMove, false);
  renderer3D.domElement.addEventListener('pointerdown', onPointerDown, true);
  window.addEventListener('keyup', onKeyUp, false);
  window.addEventListener('resize', onResize, false);
  document.addEventListener('pointerlockchange', onPointerLockChange, false);

  animate();
  </script>
</body>
</html>