<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Threesometric â€“ Glasskiva + CameraControls</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; overflow: hidden; background-color: #0f3a2d; cursor: crosshair; }
    canvas { display: block; position: absolute; top: 0; left: 0; }
    #virtual-cursor {
      position: fixed;
      width: 12px;
      height: 12px;
      border: 2px solid white;
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 9999;
      box-sizing: border-box;
    }
    #hud {
      position: fixed; left: 8px; bottom: 8px; z-index: 10000;
      font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:#ddd; opacity:.85; background: rgba(0,0,0,.25); padding:8px 10px; border-radius:8px;
      backdrop-filter: blur(6px);
    }
    #hud kbd { background:#111; padding:1px 4px; border-radius:4px; border:1px solid #333; }
  </style>
</head>
<body>
  <div id="virtual-cursor"></div>
  <div id="hud">
    <div><strong>Inspektion:</strong> rotera/pan/zoom â€¢ <strong>Klick:</strong> vÃ¤lj startpunkt â†’ RitlÃ¤ge</div>
    <div><strong>RitlÃ¤ge:</strong> pan/zoom tillÃ¥tet (rotation av). VÃ¤nsterklick = commit, <kbd>Esc</kbd> = avbryt â†’ Inspektion</div>
    <div>Vinkel snÃ¤pps vid commit (30Â°, 90Â°, 150Â°, 210Â°, 270Â°, 330Â°)</div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/examples/jsm/controls/CameraControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/CameraControls.js"
    }
  }
  </script>

  <script type="module">
  import * as THREE from 'three';
  import CameraControls from 'camera-controls';
  CameraControls.install({ THREE });

  // --- Scen, kamera, renderer ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f3a2d);

  const frustumSize = 20;
  const aspect = window.innerWidth / window.innerHeight;
  const camera = new THREE.OrthographicCamera(
    -frustumSize * aspect / 2,
     frustumSize * aspect / 2,
     frustumSize / 2,
    -frustumSize / 2,
    1e-4,             // Fasta, stora clipping-plan
    1e9
  );
  camera.position.set(50, 50, 50);
  camera.lookAt(0,0,0);

  const renderer3D = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
  renderer3D.setSize(window.innerWidth, window.innerHeight);
  renderer3D.sortObjects = true;
  document.body.appendChild(renderer3D.domElement);

  const clock = new THREE.Clock();
  const controls = new CameraControls(camera, renderer3D.domElement);
  controls.enabled = true;
  controls.mouseButtons.left   = CameraControls.ACTION.NONE;   // vi hanterar vÃ¤nsterklick sjÃ¤lva
  controls.mouseButtons.middle = CameraControls.ACTION.TRUCK;  // pan
  controls.mouseButtons.right  = CameraControls.ACTION.ROTATE; // rotation (stÃ¤ngs av i ritlÃ¤ge)
  controls.minZoom = 0.1;
  controls.maxZoom = 10;
  controls.smoothTime = 0.05;
  controls.draggingSmoothTime = 0.01;
  controls.truckSpeed = 4.0;
  controls.dollyToCursor = true; // pÃ¥ i inspektion, av i ritlÃ¤ge

  // ---- SCENE CONTENT ----
  const gridHelper = new THREE.GridHelper(100, 100, 0x3a6f62, 0x64b2a3);
  gridHelper.renderOrder = 0; // bakom linjerna
  scene.add(gridHelper);

  const idleMarker = new THREE.Mesh(
    new THREE.SphereGeometry(0.2, 16, 8),
    new THREE.MeshBasicMaterial({ color: 0xffffff })
  );
  idleMarker.renderOrder = 2;
  scene.add(idleMarker);

  const pickPlaneMesh = new THREE.Mesh(
    new THREE.PlaneGeometry(100, 100),
    new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide })
  );
  pickPlaneMesh.rotation.x = -Math.PI / 2;
  scene.add(pickPlaneMesh);

  const raycaster = new THREE.Raycaster();

  const overlay = document.createElement('canvas');
  overlay.width = window.innerWidth;
  overlay.height = window.innerHeight;
  overlay.style.pointerEvents = 'none';
  document.body.appendChild(overlay);
  const ctx = overlay.getContext('2d');

  const virtualCursorEl = document.getElementById('virtual-cursor');
  let virtualCursorPix = { x: 0, y: 0 };
  let start2D = { x: 0, y: 0 };
  let lineStartPoint = new THREE.Vector3();

  const modelGroup = new THREE.Group();
  scene.add(modelGroup);

  const permanentLines = [];
  const permanentVertices = new THREE.Group();
  modelGroup.add(permanentVertices);

  // --- BASELINE fÃ¶r fit ---
  const BASELINE_BOUNDS = new THREE.Box3(
    new THREE.Vector3(-60,-5,-60),
    new THREE.Vector3( 60, 5, 60)
  );

  // --- ISO referens ---
  const ISO_TARGET0 = new THREE.Vector3(0,0,0);
  const ISO_OFFSET  = camera.position.clone().sub(ISO_TARGET0);
  const sph = new THREE.Spherical().setFromVector3(ISO_OFFSET.clone());
  const ISO_THETA = sph.theta, ISO_PHI = sph.phi;

  // --- lÃ¤gen ---
  let isDrawing = false;
  let hasStart = false;
  let isInteracting = false; // TRUE mellan controlstart/controlend
  let pendingDraw = false;   // ðŸ‘ˆ vÃ¤nta tills pointer lock innan gummisnodden startar

  // --- utilities ---
  function addVertexSphere(pos, color=0xffdede) {
    const s = new THREE.Mesh(
      new THREE.SphereGeometry(0.1, 16, 8),
      new THREE.MeshBasicMaterial({ color, depthTest:false, depthWrite:false })
    );
    s.renderOrder = 1;
    s.position.copy(pos);
    permanentVertices.add(s);
  }

  function makeLineMaterial() {
    return new THREE.LineBasicMaterial({
      color: 0xffffff,
      transparent: false,
      depthTest: false,   // linjerna klipps inte av z-buffer
      depthWrite: false
    });
  }

  function getNDCFromEvent(e) {
    const rect = renderer3D.domElement.getBoundingClientRect();
    const x = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
    const y = -( (e.clientY - rect.top) / rect.height ) * 2 + 1;
    return new THREE.Vector2(x, y);
  }

  function projectTo2D(v3) {
    const v = v3.clone().project(camera);
    return { x: (v.x + 1) * 0.5 * overlay.width, y: (-v.y + 1) * 0.5 * overlay.height };
  }

  // --- dela kalibreringen ---
  function recomputeStart2D() {
    start2D = projectTo2D(lineStartPoint); // uppdatera endast projektionen
  }
  function recenterCursorToStart() {
    recomputeStart2D();
    setVirtualCursorTo2D({ x: start2D.x, y: start2D.y }); // flytta pekaren
  }

  function setVirtualCursorTo2D(pix) {
    virtualCursorPix.x = pix.x; virtualCursorPix.y = pix.y;
    const clampedX = Math.max(-9999, Math.min(window.innerWidth + 9999, pix.x));
    const clampedY = Math.max(-9999, Math.min(window.innerHeight + 9999, pix.y));
    virtualCursorEl.style.left = clampedX + 'px'; virtualCursorEl.style.top = clampedY + 'px';
  }

  function pixelsPerWorldUnit(dir3D, origin3D) {
    const step = 1;
    const p0 = projectTo2D(origin3D);
    const p1 = projectTo2D(origin3D.clone().add(dir3D.clone().normalize().multiplyScalar(step)));
    const dx = p1.x - p0.x, dy = p1.y - p0.y;
    const d = Math.hypot(dx, dy);
    return d < 1e-6 ? 1e-6 : d;
  }

  const ISO_ANGLES = [30, 90, 150, 210, 270, 330];
  function angleToIsoDir3D(angleDeg) {
    const dirs = {
      330: new THREE.Vector3( 1,  0,  0),
       30: new THREE.Vector3( 0,  0, -1),
       90: new THREE.Vector3( 0,  1,  0),
      150: new THREE.Vector3(-1,  0,  0),
      210: new THREE.Vector3( 0,  0,  1),
      270: new THREE.Vector3( 0, -1,  0),
    };
    return dirs[angleDeg].clone();
  }

  function snapAngleDeg(rawAngle) {
    const norm = ((rawAngle % 360) + 360) % 360;
    let best = ISO_ANGLES[0], bestDiff = 1e9;
    for (const a of ISO_ANGLES) {
      const d = Math.min(Math.abs(norm - a), 360 - Math.abs(norm - a));
      if (d < bestDiff) { bestDiff = d; best = a; }
    }
    return best;
  }

  function drawOverlay() {
    ctx.clearRect(0,0,overlay.width, overlay.height);
    if (hasStart) {
      ctx.fillStyle = 'rgba(255,200,200,.9)';
      ctx.beginPath(); ctx.arc(start2D.x, start2D.y, 3, 0, Math.PI*2); ctx.fill();
    }
    if (hasStart && isDrawing) {
      ctx.strokeStyle = 'white'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(start2D.x, start2D.y); ctx.lineTo(virtualCursorPix.x, virtualCursorPix.y); ctx.stroke();
    }
  }

  // Kamerahelpers (frustum-mesh kan kommenteras pÃ¥/av)
  function buildOrUpdateFrustumBox() {}

  // Kamera/utils
  function lookIsoAt(target, smooth=false) {
    const pos = target.clone().add(ISO_OFFSET);
    return controls.setLookAt(pos.x, pos.y, pos.z, target.x, target.y, target.z, smooth);
  }

  // ISO-fit: berÃ¤kna bara zoom/pan â€“ INTE near/far
  async function fitBoxOrthoIso(box, paddingRatio = 0.08, smooth = true) {
    const prev = {
      minPolar: controls.minPolarAngle, maxPolar: controls.maxPolarAngle,
      minAzim: controls.minAzimuthAngle, maxAzim: controls.maxAzimuthAngle,
      rightMouse: controls.mouseButtons.right,
      dollyToCursor: controls.dollyToCursor,
    };
    controls.minPolarAngle = controls.maxPolarAngle = ISO_PHI;
    controls.minAzimuthAngle = controls.maxAzimuthAngle = ISO_THETA;
    controls.mouseButtons.right = CameraControls.ACTION.NONE;
    controls.dollyToCursor = true;

    const target = box.getCenter(new THREE.Vector3());
    await lookIsoAt(target, smooth);

    // Extenter i kamerarummet:
    camera.updateMatrixWorld(true);
    const view = camera.matrixWorldInverse;
    const corners = [
      new THREE.Vector3(box.min.x, box.min.y, box.min.z),
      new THREE.Vector3(box.min.x, box.min.y, box.max.z),
      new THREE.Vector3(box.min.x, box.max.y, box.min.z),
      new THREE.Vector3(box.min.x, box.max.y, box.max.z),
      new THREE.Vector3(box.max.x, box.min.y, box.min.z),
      new THREE.Vector3(box.max.x, box.min.y, box.max.z),
      new THREE.Vector3(box.max.x, box.max.y, box.min.z),
      new THREE.Vector3(box.max.x, box.max.y, box.max.z),
    ];
    let minX=+Infinity, maxX=-Infinity, minY=+Infinity, maxY=-Infinity;
    for (const w of corners) {
      const v = w.clone().applyMatrix4(view);
      minX = Math.min(minX, v.x);  maxX = Math.max(maxX, v.x);
      minY = Math.min(minY, v.y);  maxY = Math.max(maxY, v.y);
    }
    const widthWorld  = maxX - minX;
    const heightWorld = maxY - minY;

    const baseWidth  = (camera.right - camera.left);
    const baseHeight = (camera.top - camera.bottom);
    const padFactor = 1 + paddingRatio * 2;

    const needZoomX = widthWorld  > 0 ? (baseWidth  / (widthWorld  * padFactor)) : controls.maxZoom;
    const needZoomY = heightWorld > 0 ? (baseHeight / (heightWorld * padFactor)) : controls.maxZoom;

    let targetZoom = Math.min(needZoomX, needZoomY);
    targetZoom = Math.min(Math.max(targetZoom, controls.minZoom), controls.maxZoom);
    await controls.zoomTo(targetZoom, smooth);

    // Ã…terstÃ¤ll kontroller
    controls.minPolarAngle   = prev.minPolar;
    controls.maxPolarAngle   = prev.maxPolar;
    controls.minAzimuthAngle = prev.minAzim;
    controls.maxAzimuthAngle = prev.maxAzim;
    controls.mouseButtons.right = prev.rightMouse;
    controls.dollyToCursor = prev.dollyToCursor;
  }

  // --- LÃ¤ge: Rit ---
  function enterDrawMode(startPoint) {
    // Aktivera inte ritningen Ã¤nnu â†’ vÃ¤nta tills pointer lock Ã¤r klart
    pendingDraw = true;   // ðŸ‘ˆ
    hasStart = true;

    // LÃ¥s ISO + stÃ¤ng av rotation; dollyToCursor AV i ritlÃ¤ge
    controls.minPolarAngle   = ISO_PHI;
    controls.maxPolarAngle   = ISO_PHI;
    controls.minAzimuthAngle = ISO_THETA;
    controls.maxAzimuthAngle = ISO_THETA;
    controls.mouseButtons.right = CameraControls.ACTION.NONE;
    controls.dollyToCursor = false;
    controls.enabled = true;

    // Flytta kameran till ISO mot startpunkten och begÃ¤r pointer lock
    return lookIsoAt(startPoint, true).then(() => {
      renderer3D.domElement.requestPointerLock();
    });
  }

  // --- LÃ¤ge: Inspektion ---
  function enterInspectModeUnlocked() {
    controls.minPolarAngle   = 0.01;
    controls.maxPolarAngle   = Math.PI - 0.01;
    controls.minAzimuthAngle = -Infinity;
    controls.maxAzimuthAngle = Infinity;
    controls.mouseButtons.right = CameraControls.ACTION.ROTATE;
    controls.dollyToCursor = true;
    controls.enabled = true;
    virtualCursorEl.style.display = 'none';
    if (document.pointerLockElement) document.exitPointerLock();
  }

  async function resetIsoAndFitAll() {
    const modelBox = new THREE.Box3().setFromObject(modelGroup);
    const fitBox = modelBox.isEmpty() ? BASELINE_BOUNDS.clone() : modelBox.union(BASELINE_BOUNDS.clone());
    await fitBoxOrthoIso(fitBox, 0.08, true);
    enterInspectModeUnlocked(); // rotation pÃ¥ efterÃ¥t
  }

  function enterInspectMode(runIsoFit=false) {
    if (!runIsoFit) {
      enterInspectModeUnlocked();
      return Promise.resolve();
    }
    return resetIsoAndFitAll();
  }

  // ---- INIT ----
  (async function init() {
    await enterInspectMode(true); // ISO-fit; near/far Ã¤r fasta & stora â†’ ingen clipping
  })();

  // --- Input ---
  function onMouseMove(e) {
    if (document.pointerLockElement) {
      if (isDrawing && hasStart) {
        setVirtualCursorTo2D({ x: virtualCursorPix.x + e.movementX, y: virtualCursorPix.y + e.movementY });
      }
    } else {
      const ndc = getNDCFromEvent(e);
      raycaster.setFromCamera(ndc, camera);
      const hit = raycaster.intersectObject(pickPlaneMesh);
      if (hit.length) idleMarker.position.copy(hit[0].point);
    }
  }

  function isPointInFrustum(point3D) {
    const v = point3D.clone().project(camera);
    return v.x >= -1 && v.x <= 1 && v.y >= -1 && v.y <= 1 && v.z >= -1 && v.z <= 1;
  }

  function onPointerDown(e) {
    if (e.button === 0) {
      if (!document.pointerLockElement) {
        // INSPEKTION: klick = vÃ¤lj startpunkt + in i ritlÃ¤ge
        const ndc = getNDCFromEvent(e);
        raycaster.setFromCamera(ndc, camera);
        const hit = raycaster.intersectObject(pickPlaneMesh);
        if (hit.length) {
          lineStartPoint.copy(hit[0].point);
          addVertexSphere(lineStartPoint, 0xffdede);
          enterDrawMode(lineStartPoint);
        }
      } else {
        // RITLÃ„GE: commit â€“ men bara om vi INTE pan/zoomar just nu
        if (isDrawing && hasStart && !isInteracting) {
          const dx = virtualCursorPix.x - start2D.x;
          const dy = start2D.y - virtualCursorPix.y;
          const rawAngle = Math.atan2(dy, dx) * 180 / Math.PI;
          const snapped = snapAngleDeg(rawAngle);
          const dir3D = angleToIsoDir3D(snapped);
          const ppu = pixelsPerWorldUnit(dir3D, lineStartPoint);
          const pixelsLen = Math.hypot(dx, dy);
          const worldLen = pixelsLen / ppu;
          if (worldLen > 1e-6) {
            const end3D = lineStartPoint.clone().add(dir3D.multiplyScalar(worldLen));
            const geom = new THREE.BufferGeometry().setFromPoints([lineStartPoint, end3D]);
            const line = new THREE.Line(geom, makeLineMaterial());
            line.renderOrder = 1; // Ã¶ver grid
            modelGroup.add(line);
            permanentLines.push(line);
            addVertexSphere(end3D, 0xffdede);
            lineStartPoint.copy(end3D);

            // Auto-pan om end Ã¤r utanfÃ¶r fÃ¶nstret (ISO bevaras)
            const maybePan = (!isPointInFrustum(end3D))
              ? lookIsoAt(end3D, true).then(() => { if (isDrawing) recenterCursorToStart(); })
              : Promise.resolve();

            maybePan.then(() => {
              recenterCursorToStart();
            });
          }
        }
      }
    }
  }

  function onKeyUp(e) {
    if (e.code === 'Escape') {
      isDrawing = false; hasStart = false; pendingDraw = false;
      virtualCursorEl.style.display = 'none';
      if (document.pointerLockElement) document.exitPointerLock();
      enterInspectMode(true); // ISO-fit (egen)
    }
  }

  function onPointerLockChange() {
    if (!document.pointerLockElement) {
      virtualCursorEl.style.display = 'none';
    } else {
      if (hasStart) {
        virtualCursorEl.style.display = 'block';
        recenterCursorToStart(); // pekaren hoppar till start fÃ¶rst NU

        if (pendingDraw) {       // ðŸ‘ˆ aktivera ritlÃ¤get efter pointer lock
          isDrawing = true;
          pendingDraw = false;
        }
      }
    }
  }

  function onResize() {
    const aspect = window.innerWidth / window.innerHeight;
    camera.left   = -frustumSize * aspect / 2;
    camera.right  =  frustumSize * aspect / 2;
    camera.top    =  frustumSize / 2;
    camera.bottom = -frustumSize / 2;
    camera.updateProjectionMatrix();
    renderer3D.setSize(window.innerWidth, window.innerHeight);
    overlay.width  = window.innerWidth;
    overlay.height = window.innerHeight;
    if (isDrawing && hasStart) recomputeStart2D(); // uppdatera endast projektion
  }

  // Synka gummisnodden under CameraControls-interaktioner
  controls.addEventListener('controlstart', () => { 
    isInteracting = true;  
    if (isDrawing && hasStart) recomputeStart2D(); // inte recenter
  });
  controls.addEventListener('control',      () => { 
    if (isDrawing && hasStart) recomputeStart2D(); // inte recenter
  });
  controls.addEventListener('controlend',   () => { 
    isInteracting = false; 
    if (isDrawing && hasStart) recomputeStart2D(); // inte recenter
  });

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    controls.update(delta);

    // Under ritlÃ¤ge: hÃ¥ll start2D i synk varje frame
    if (isDrawing && hasStart) recomputeStart2D();

    buildOrUpdateFrustumBox();
    renderer3D.render(scene, camera);
    drawOverlay();
  }

  renderer3D.domElement.addEventListener('mousemove', onMouseMove, false);
  renderer3D.domElement.addEventListener('pointerdown', onPointerDown, true);
  window.addEventListener('keyup', onKeyUp, false);
  window.addEventListener('resize', onResize, false);
  document.addEventListener('pointerlockchange', onPointerLockChange, false);

  animate();
  </script>
</body>
</html>
